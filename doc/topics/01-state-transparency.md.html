<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>hug - Documentation</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>hug</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>



<h2>Topics</h2>
<ul>
  <li><strong>01-state-transparency.md</strong></li>
</ul>
<h2>Modules</h2>
<ul>
  <li><a href="../modules/basicgame.html">basicgame</a></li>
  <li><a href="../modules/cache.html">cache</a></li>
  <li><a href="../modules/camera.html">camera</a></li>
  <li><a href="../modules/chasecamera.html">chasecamera</a></li>
  <li><a href="../modules/color.html">color</a></li>
  <li><a href="../modules/extensions.extension.html">extensions.extension</a></li>
  <li><a href="../modules/extensions.math.html">extensions.math</a></li>
  <li><a href="../modules/extensions.string.html">extensions.string</a></li>
  <li><a href="../modules/extensions.table.html">extensions.table</a></li>
  <li><a href="../modules/gameloop.html">gameloop</a></li>
  <li><a href="../modules/gamestate.html">gamestate</a></li>
  <li><a href="../modules/lazy.html">lazy</a></li>
  <li><a href="../modules/rectangle.html">rectangle</a></li>
  <li><a href="../modules/statemachine.html">statemachine</a></li>
  <li><a href="../modules/timer.html">timer</a></li>
  <li><a href="../modules/timerpool.html">timerpool</a></li>
  <li><a href="../modules/vector2.html">vector2</a></li>
</ul>

</div>

<div id="content">

<h1>Topic <code>01-state-transparency.md</code></h1>


<h1>Game State Transparency</h1>

<p>Transparency is the method hug uses to deal with multiple visible gamestates in the gamestate stack. When the topmost gamestate is marked as transparent, any underlying states are rendered first. Rendering starts at the first opaque state encountered from the top of the stack or at the bottommost state if all states in the stack are transparent. Additionally, LÃ–VE callbacks are called on each transparent state from top to bottom. At any point in the transparency stack, a gamestate can intercept the callback so that it is not passed to underlying states.</p>

<p><a href="../modules/gamestate.html#">gamestate</a>  objects can be flagged as transparent through the <code>transparent</code> field on a <a href="../modules/gamestate.html#">gamestate</a>  instance. By default, properly implemented gamestates are opaque - any code that looks for the <code>transparent</code> field by default should find the default value in <code>hug.gamestate</code> by climbing the <code>__index</code> chain. To intercept an event so that it is not propagated downwards, return <code>false</code> from your callback.</p>

<h1>Example</h1>

<pre><code> -- instructions:
 -- press ESC to pause the timer

 local gamestate = require('hug.gamestate')
 local playstate = gamestate.extend()
 playstate.__index = playstate

 local pausestate = gamestate.extend()
 pausestate.__index = pausestate

 local font = love.graphics.setNewFont(48)

 function playstate.new()
   return setmetatable({t = 0}, playstate)
 end
 function playstate:keypressed(key)
   if key == 'escape' then
     self:sm():push(pausestate.new())
   end
 end
 function playstate:update(dt)
   self.t = self.t + dt
 end
 function playstate:draw()
   -- draw a red screen with some dynamic text
   local w, h = love.graphics.getDimensions()
   love.graphics.setColor(120, 55, 55)
   love.graphics.rectangle('fill', 0, 0, w, h)

   local text = 'Seconds passed: ' .. math.floor(self.t)
   local tw, th = font:getWidth(text), font:getHeight()
   local tx, ty = w / 2 - tw / 2, h / 2 - th / 2 - 150

   love.graphics.setColor(255, 255, 255)
   love.graphics.print('Seconds passed: ' .. math.floor(self.t), tx, ty)
 end

 function pausestate.new()
   return setmetatable({transparent = true}, pausestate)
 end
 function pausestate:keypressed(key)
   if key == 'escape' then
     self:sm():pop()
   end
   -- this intercepts all input so that the underlying state doesn't process it
   return false
 end
 function pausestate:update()
   -- this prevents update ticks on the underlying state
   return false
 end
 function pausestate:draw()
   -- draw a 50% transparent, black overlay
   local w, h = love.graphics.getDimensions()
   love.graphics.setColor(0, 0, 0, 128)
   love.graphics.rectangle('fill', 0, 0, w, h)

   local text = 'PAUSED - Press ESC to unpause'
   local tw, th = font:getWidth(text), font:getHeight()
   local tx, ty = w / 2 - tw / 2, h / 2 - th / 2
   love.graphics.setColor(255, 255, 255)
   love.graphics.print('PAUSED - Press ESC to unpause', tx, ty)
 end

 local basicgame = require('hug.basicgame')
 basicgame.start(playstate.new())
</code></pre>




</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.3.12</a></i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
